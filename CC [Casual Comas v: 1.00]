local HttpService = game:GetService('HttpService')
local CoreGui = game:GetService('CoreGui')
local urls = {
    'https://raw.githubusercontent.com/Nahalliaa/CasualComas/refs/heads/main/P1.luau',
    'https://raw.githubusercontent.com/Nahallia/Cc/refs/heads/main/Part2.luau',
    'https://raw.githubusercontent.com/Nahalliaa/CasualComas/refs/heads/main/CarMods',
}

for _, url in ipairs(urls)do
    loadstring(game:HttpGet(url))()
end

task.spawn(function()
    task.wait(1)

    local function findRayfield()
        for _, gui in ipairs(CoreGui:GetChildren())do
            local rf = gui:FindFirstChild('Rayfield')

            if rf then
                return rf
            end
        end
    end
    local function apply()
        local rayfield = findRayfield()

        if not rayfield then
            return
        end

        local prompt = rayfield:FindFirstChild('Prompt')

        if not prompt then
            return
        end
        if prompt:IsA('Frame') or prompt:IsA('TextButton') or prompt:IsA('ImageButton') then
            prompt.BackgroundColor3 = Color3.fromRGB(58, 48, 68)
        end

        local title = prompt:FindFirstChild('Title')

        if title and title:IsA('TextLabel') then
            title.Text = 'Casual Comas'
            title.TextColor3 = Color3.fromRGB(240, 235, 230)
        end
    end

    apply()

    while task.wait(1.5) do
        apply()
    end
end)

local Env = getgenv().PL_Hub

if not Env then
    return warn('Load Part 1 First!')
end

local HttpService = Env.Services.HttpService
local ReplicatedStorage = Env.Services.ReplicatedStorage
local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer
local RunService = Env.Services.RunService
local Workspace = game:GetService('Workspace')

if Env.cfg.autoarrest == nil then
    Env.cfg.autoarrest = false
end
if Env.cfg.punchaura == nil then
    Env.cfg.punchaura = false
end
if Env.cfg.ws_enabled == nil then
    Env.cfg.ws_enabled = false
end
if Env.cfg.walkspeed == nil then
    Env.cfg.walkspeed = 16
end
if Env.cfg.jp_enabled == nil then
    Env.cfg.jp_enabled = false
end
if Env.cfg.jumppower == nil then
    Env.cfg.jumppower = 50
end
if Env.cfg.noclip == nil then
    Env.cfg.noclip = false
end
if Env.cfg.shootarrested == nil then
    Env.cfg.shootarrested = false
end
if Env.cfg.autograb == nil then
    Env.cfg.autograb = false
end

local noclipConnection = nil

local function updateNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()

        noclipConnection = nil
    end
    if Env.cfg.noclip then
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character

            if char then
                for _, part in pairs(char:GetDescendants())do
                    if part:IsA('BasePart') then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end

task.spawn(function()
    pcall(function()
        local hook = newcclosure(function()
            return
        end)

        for _, obj in getgc(false)do
            if typeof(obj) == 'function' then
                local source = debug.info(obj, 's')

                if source and source:find('CharacterCollision') then
                    hookfunction(obj, hook)
                end
            end
        end
    end)
end)
task.spawn(function()
    while true do
        if Env.cfg.shootarrested then
            local rs = ReplicatedStorage
            local re = rs:FindFirstChild('Remotes') and rs.Remotes:FindFirstChild('ClientArrested')

            if re then
                for _, cn in pairs(getconnections(re.OnClientEvent))do
                    cn:Disable()
                end
            end
        end

        task.wait(1)
    end
end)

local grab_dist_sq = 144
local last_grab = 0
local giver_remote = ReplicatedStorage:WaitForChild('Remotes'):FindFirstChild('GiverPressed')
local grab_cache = {}
local cache_update_interval = 2
local last_cache_update = 0

local function updateGrabCache()
    grab_cache = {}

    for _, obj in pairs(Workspace:GetDescendants())do
        if obj:IsA('Model') and (obj.Name:lower():find('keycard') or obj.Name == 'M9') then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA('BasePart', true)

            if part then
                local isOwned = false
                local anc = obj.Parent

                while anc and anc ~= Workspace do
                    if anc:FindFirstChild('Humanoid') or anc.Name == 'Backpack' then
                        isOwned = true

                        break
                    end

                    anc = anc.Parent
                end

                if not isOwned then
                    table.insert(grab_cache, {
                        model = obj,
                        part = part,
                    })
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(function()
    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')
    local myHum = myChar and myChar:FindFirstChild('Humanoid')

    if myHum and myHrp then
        if Env.cfg.ws_enabled then
            myHum.WalkSpeed = Env.cfg.walkspeed
        end
        if Env.cfg.jp_enabled then
            myHum.JumpPower = Env.cfg.jumppower
        end
    end
    if Env.cfg.autograb and myHrp and giver_remote then
        local now = tick()

        if now - last_cache_update > cache_update_interval then
            updateGrabCache()

            last_cache_update = now
        end
        if now - last_grab > 0.5 then
            for _, cached in ipairs(grab_cache)do
                if cached.model and cached.part and cached.part.Parent then
                    local distSq = (cached.part.Position - myHrp.Position).Magnitude ^ 2

                    if distSq <= grab_dist_sq then
                        last_grab = now

                        giver_remote:FireServer(cached.model)

                        break
                    end
                end
            end
        end
    end
    if (Env.cfg.autoarrest or Env.cfg.punchaura) and myHrp then
        for _, target in ipairs(Players:GetPlayers())do
            if target ~= LocalPlayer and target.Character and target.Character:FindFirstChild('HumanoidRootPart') then
                local targetHrp = target.Character.HumanoidRootPart
                local dist = (targetHrp.Position - myHrp.Position).Magnitude

                if dist <= 25 then
                    if Env.cfg.autoarrest and LocalPlayer.Team == Env.Teams.Guards then
                        if target.Team == Env.Teams.Criminals or target.Team == Env.Teams.Inmates then
                            if not target.Character:FindFirstChild('ForceField') then
                                task.spawn(function()
                                    pcall(function()
                                        ReplicatedStorage.Remotes.ArrestPlayer:InvokeServer(target.Character.HumanoidRootPart)
                                    end)
                                end)
                            end
                        end
                    end
                    if Env.cfg.punchaura and target.Team ~= LocalPlayer.Team then
                        if not target.Character:FindFirstChild('ForceField') then
                            ReplicatedStorage.meleeEvent:FireServer(target)
                        end
                    end
                end
            end
        end
    end
end)

local configFolder = 'CasualComasConfigs'

local function serializeColor3(color)
    return {
        R = color.R,
        G = color.G,
        B = color.B,
    }
end
local function deserializeColor3(tbl)
    if tbl and tbl.R and tbl.G and tbl.B then
        return Color3.new(tbl.R, tbl.G, tbl.B)
    end

    return Color3.new(1, 1, 1)
end
local function serializeConfig()
    local data = {}

    for key, value in pairs(Env.cfg)do
        if typeof(value) == 'Color3' then
            data[key] = {
                type = 'Color3',
                value = serializeColor3(value),
            }
        elseif typeof(value) == 'EnumItem' then
            data[key] = {
                type = 'EnumItem',
                value = tostring(value),
            }
        elseif typeof(value) == 'table' then
            data[key] = {
                type = 'table',
                value = value,
            }
        else
            data[key] = {
                type = typeof(value),
                value = value,
            }
        end
    end

    return HttpService:JSONEncode(data)
end
local function deserializeConfig(jsonString)
    local success, data = pcall(function()
        return HttpService:JSONDecode(jsonString)
    end)

    if not success then
        return nil
    end

    local result = {}

    for key, entry in pairs(data)do
        if entry.type == 'Color3' then
            result[key] = deserializeColor3(entry.value)
        elseif entry.type == 'EnumItem' then
            local enumPath = entry.value:match('Enum%.(.+)')

            if enumPath then
                local parts = enumPath:split('.')

                if #parts == 2 then
                    local enumType = Enum[parts[1] ]

                    if enumType then
                        result[key] = enumType[parts[2] ]
                    end
                end
            end
        elseif entry.type == 'table' then
            result[key] = entry.value
        else
            result[key] = entry.value
        end
    end

    return result
end
local function saveConfig(name)
    if not isfolder then
        return false
    end
    if not isfolder(configFolder) then
        makefolder(configFolder)
    end

    local path = configFolder .. '/' .. name .. '.json'

    writefile(path, serializeConfig())

    return true
end
local function loadConfig(name)
    if not isfolder or not isfile then
        return false
    end

    local path = configFolder .. '/' .. name .. '.json'

    if not isfile(path) then
        return false
    end

    local data = readfile(path)
    local loaded = deserializeConfig(data)

    if not loaded then
        return false
    end

    for key, value in pairs(loaded)do
        if Env.cfg[key] ~= nil then
            Env.cfg[key] = value
        end
    end

    if Env.updateEsp then
        Env.updateEsp()
    end
    if Env.updateC4Esp then
        Env.updateC4Esp()
    end

    updateNoclip()

    return true
end

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local customTheme = {
    TextColor = Color3.fromRGB(220, 215, 210),
    Background = Color3.fromRGB(16, 14, 20),
    Topbar = Color3.fromRGB(22, 19, 26),
    Shadow = Color3.fromRGB(6, 5, 8),
    NotificationBackground = Color3.fromRGB(24, 21, 30),
    NotificationActionsBackground = Color3.fromRGB(30, 26, 36),
    TabBackground = Color3.fromRGB(20, 18, 26),
    TabStroke = Color3.fromRGB(45, 40, 55),
    TabBackgroundSelected = Color3.fromRGB(34, 30, 42),
    TabTextColor = Color3.fromRGB(150, 145, 150),
    SelectedTabTextColor = Color3.fromRGB(235, 230, 225),
    ElementBackground = Color3.fromRGB(22, 20, 28),
    ElementBackgroundHover = Color3.fromRGB(30, 26, 36),
    SecondaryElementBackground = Color3.fromRGB(20, 18, 26),
    ElementStroke = Color3.fromRGB(50, 45, 65),
    SecondaryElementStroke = Color3.fromRGB(42, 38, 52),
    SliderBackground = Color3.fromRGB(32, 28, 40),
    SliderProgress = Color3.fromRGB(150, 95, 175),
    SliderStroke = Color3.fromRGB(60, 55, 70),
    ToggleBackground = Color3.fromRGB(22, 20, 28),
    ToggleEnabled = Color3.fromRGB(145, 95, 170),
    ToggleDisabled = Color3.fromRGB(55, 52, 62),
    ToggleEnabledStroke = Color3.fromRGB(165, 115, 190),
    ToggleDisabledStroke = Color3.fromRGB(38, 36, 44),
    ToggleEnabledOuterStroke = Color3.fromRGB(28, 26, 32),
    ToggleDisabledOuterStroke = Color3.fromRGB(22, 20, 26),
    DropdownSelected = Color3.fromRGB(30, 26, 36),
    DropdownUnselected = Color3.fromRGB(22, 20, 28),
    InputBackground = Color3.fromRGB(20, 18, 26),
    InputStroke = Color3.fromRGB(48, 44, 60),
    PlaceholderColor = Color3.fromRGB(120, 115, 120),
}
local Window = Rayfield:CreateWindow({
    Name = 'Casual Comas',
    Icon = 79844328689721,
    LoadingTitle = 'Casual Comas Hub',
    LoadingSubtitle = 'v' .. Env.Version,
    Theme = customTheme,
    ConfigurationSaving = {Enabled = false},
    KeySystem = false,
})
local CombatTab = Window:CreateTab('Combat', 'crosshair')
local VisualsTab = Window:CreateTab('Visuals', 'eye')
local MovementTab = Window:CreateTab('Movement', 'wind')
local VehicleTab = Window:CreateTab('Vehicle', 'car')
local UtilityTab = Window:CreateTab('Utility', 'box')
local ConfigTab = Window:CreateTab('Config', 'settings')

CombatTab:CreateSection('Silent Aim')
CombatTab:CreateToggle({
    Name = 'Enable Silent Aim',
    CurrentValue = Env.cfg.enabled,
    Callback = function(v)
        Env.cfg.enabled = v
    end,
})
CombatTab:CreateSlider({
    Name = 'FOV Radius',
    Range = {10, 500},
    Increment = 1,
    Suffix = 'px',
    CurrentValue = Env.cfg.fov,
    Callback = function(v)
        Env.cfg.fov = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Show FOV Circle',
    CurrentValue = Env.cfg.showfov,
    Callback = function(v)
        Env.cfg.showfov = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Hit Chance',
    Range = {0, 100},
    Increment = 1,
    Suffix = '%',
    CurrentValue = Env.cfg.hitchance,
    Callback = function(v)
        Env.cfg.hitchance = v
    end,
})
CombatTab:CreateDropdown({
    Name = 'Target Part',
    Options = Env.cfg.partslist,
    CurrentOption = {
        Env.cfg.aimpart,
    },
    MultipleOptions = false,
    Callback = function(o)
        Env.cfg.aimpart = o[1]
    end,
})
CombatTab:CreateToggle({
    Name = 'Random Parts',
    CurrentValue = Env.cfg.randomparts,
    Callback = function(v)
        Env.cfg.randomparts = v
    end,
})
CombatTab:CreateSection('Targeting')
CombatTab:CreateToggle({
    Name = 'Team Check',
    CurrentValue = Env.cfg.teamcheck,
    Callback = function(v)
        Env.cfg.teamcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Wall Check',
    CurrentValue = Env.cfg.wallcheck,
    Callback = function(v)
        Env.cfg.wallcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Death Check',
    CurrentValue = Env.cfg.deathcheck,
    Callback = function(v)
        Env.cfg.deathcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'ForceField Check',
    CurrentValue = Env.cfg.ffcheck,
    Callback = function(v)
        Env.cfg.ffcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Vehicle Check',
    CurrentValue = Env.cfg.vehiclecheck,
    Callback = function(v)
        Env.cfg.vehiclecheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Hostile Check (Guards)',
    CurrentValue = Env.cfg.hostilecheck,
    Callback = function(v)
        Env.cfg.hostilecheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Trespass Check (Guards)',
    CurrentValue = Env.cfg.trespasscheck,
    Callback = function(v)
        Env.cfg.trespasscheck = v
    end,
})
CombatTab:CreateSection('Automation')
CombatTab:CreateToggle({
    Name = 'Auto Shoot',
    CurrentValue = Env.cfg.autoshoot,
    Callback = function(v)
        Env.cfg.autoshoot = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Shot Delay',
    Range = {0.05, 0.5},
    Increment = 0.01,
    Suffix = 's',
    CurrentValue = Env.cfg.autoshootdelay,
    Callback = function(v)
        Env.cfg.autoshootdelay = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Start Delay',
    Range = {0, 1},
    Increment = 0.05,
    Suffix = 's',
    CurrentValue = Env.cfg.autoshootstartdelay,
    Callback = function(v)
        Env.cfg.autoshootstartdelay = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Auto Arrest (Guard)',
    CurrentValue = Env.cfg.autoarrest,
    Callback = function(v)
        Env.cfg.autoarrest = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Punch Aura',
    CurrentValue = Env.cfg.punchaura,
    Callback = function(v)
        Env.cfg.punchaura = v
    end,
})
CombatTab:CreateSection('Shield Breaker')
CombatTab:CreateToggle({
    Name = 'Enable Shield Breaker',
    CurrentValue = Env.cfg.shieldbreaker,
    Callback = function(v)
        Env.cfg.shieldbreaker = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Head Shot Chance',
    Range = {0, 100},
    Increment = 1,
    Suffix = '%',
    CurrentValue = Env.cfg.shieldheadchance,
    Callback = function(v)
        Env.cfg.shieldheadchance = v
    end,
})
VisualsTab:CreateSection('Player ESP')
VisualsTab:CreateToggle({
    Name = 'Enable ESP',
    CurrentValue = Env.cfg.esp,
    Callback = function(v)
        Env.cfg.esp = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateToggle({
    Name = 'Team Check',
    CurrentValue = Env.cfg.espteamcheck,
    Callback = function(v)
        Env.cfg.espteamcheck = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateToggle({
    Name = 'Use Team Colors',
    CurrentValue = Env.cfg.espuseteamcolors,
    Callback = function(v)
        Env.cfg.espuseteamcolors = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSlider({
    Name = 'Max Distance',
    Range = {50, 1000},
    Increment = 10,
    Suffix = 'm',
    CurrentValue = Env.cfg.espmaxdist,
    Callback = function(v)
        Env.cfg.espmaxdist = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSection('Team Colors')
VisualsTab:CreateColorPicker({
    Name = 'Guards',
    Color = Env.cfg.espguards,
    Callback = function(v)
        Env.cfg.espguards = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'Inmates',
    Color = Env.cfg.espinmates,
    Callback = function(v)
        Env.cfg.espinmates = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'Criminals',
    Color = Env.cfg.espcriminals,
    Callback = function(v)
        Env.cfg.espcriminals = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSection('C4 ESP')
VisualsTab:CreateToggle({
    Name = 'Enable C4 ESP',
    CurrentValue = Env.cfg.c4esp,
    Callback = function(v)
        Env.cfg.c4esp = v

        Env.updateC4Esp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'C4 Color',
    Color = Env.cfg.c4espcolor,
    Callback = function(v)
        Env.cfg.c4espcolor = v

        Env.updateC4Esp()
    end,
})

VisualsTab:CreateSection("Camera")

VisualsTab:CreateSlider({
    Name = "Camera FOV",
    Range = { 70, 120 },
    Increment = 1,
    CurrentValue = Workspace.CurrentCamera.FieldOfView,
    Callback = function(v)
        Workspace.CurrentCamera.FieldOfView = v
    end
})

local VisualsSection = VisualsTab:CreateSection("Visual Features")

local TracerToggle = VisualsTab:CreateToggle({
    Name = "Enable Tracers",
    CurrentValue = Env.cfg.tracer.enabled,
    Flag = "TracerToggle",
    Callback = function(Value)
        Env.cfg.tracer.enabled = Value
    end,
})

local TracerColor = VisualsTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = Env.cfg.tracer.color,
    Flag = "TracerColor",
    Callback = function(Value)
        Env.cfg.tracer.color = Value
    end
})

local TracerThickness = VisualsTab:CreateSlider({
    Name = "Tracer Thickness",
    Range = {0.05, 0.5},
    Increment = 0.01,
    CurrentValue = Env.cfg.tracer.thickness,
    Flag = "TracerThickness",
    Callback = function(Value)
        Env.cfg.tracer.thickness = Value
    end,
})

local TracerLifetime = VisualsTab:CreateSlider({
    Name = "Tracer Lifetime",
    Range = {0.1, 1},
    Increment = 0.05,
    CurrentValue = Env.cfg.tracer.lifetime,
    Flag = "TracerLifetime",
    Callback = function(Value)
        Env.cfg.tracer.lifetime = Value
    end,
})

local TracerFade = VisualsTab:CreateSlider({
    Name = "Tracer Fade Duration",
    Range = {0.1, 1},
    Increment = 0.05,
    CurrentValue = Env.cfg.tracer.fade,
    Flag = "TracerFade",
    Callback = function(Value)
        Env.cfg.tracer.fade = Value
    end,
})

local HitSoundSection = VisualsTab:CreateSection("Hit Sound")

local HitSoundToggle = VisualsTab:CreateToggle({
    Name = "Enable Hit Sound",
    CurrentValue = Env.cfg.hitsound.enabled,
    Flag = "HitSoundToggle",
    Callback = function(Value)
        Env.cfg.hitsound.enabled = Value
    end,
})

local HitSoundVolume = VisualsTab:CreateSlider({
    Name = "Hit Sound Volume",
    Range = {0, 5},
    Increment = 0.1,
    CurrentValue = Env.cfg.hitsound.volume,
    Flag = "HitSoundVolume",
    Callback = function(Value)
        Env.cfg.hitsound.volume = Value
        HitSound.Volume = Value
    end,
})

local NormalHitSound = VisualsTab:CreateInput({
    Name = "Normal Hit Sound ID",
    PlaceholderText = "Asset ID",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Env.cfg.hitsound.normal),
    Flag = "NormalHitSound",
    Callback = function(Value)
        local id = tonumber(Value)
        if id then
            Env.cfg.hitsound.normal = id
        end
    end,
})

local HeadshotSound = VisualsTab:CreateInput({
    Name = "Headshot Sound ID",
    PlaceholderText = "Asset ID",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Env.cfg.hitsound.headshot),
    Flag = "HeadshotSound",
    Callback = function(Value)
        local id = tonumber(Value)
        if id then
            Env.cfg.hitsound.headshot = id
        end
    end,
})

local HitmarkerSection = VisualsTab:CreateSection("Hitmarker")

local HitmarkerToggle = VisualsTab:CreateToggle({
    Name = "Enable Hitmarker",
    CurrentValue = Env.cfg.hitmarker.enabled,
    Flag = "HitmarkerToggle",
    Callback = function(Value)
        Env.cfg.hitmarker.enabled = Value
    end,
})

local HitmarkerThickness = VisualsTab:CreateSlider({
    Name = "Hitmarker Thickness",
    Range = {1, 5},
    Increment = 0.5,
    CurrentValue = Env.cfg.hitmarker.thickness,
    Flag = "HitmarkerThickness",
    Callback = function(Value)
        Env.cfg.hitmarker.thickness = Value
    end,
})

local HitmarkerLength = VisualsTab:CreateSlider({
    Name = "Hitmarker Length",
    Range = {3, 15},
    Increment = 1,
    CurrentValue = Env.cfg.hitmarker.length,
    Flag = "HitmarkerLength",
    Callback = function(Value)
        Env.cfg.hitmarker.length = Value
    end,
})

local HitmarkerGap = VisualsTab:CreateSlider({
    Name = "Hitmarker Gap",
    Range = {1, 10},
    Increment = 1,
    CurrentValue = Env.cfg.hitmarker.gap,
    Flag = "HitmarkerGap",
    Callback = function(Value)
        Env.cfg.hitmarker.gap = Value
    end,
})

local CrosshairSection = VisualsTab:CreateSection("Crosshair")

local CustomCrosshair = VisualsTab:CreateInput({
    Name = "Custom Crosshair Image ID",
    PlaceholderText = "Asset ID (leave empty for default)",
    RemoveTextAfterFocusLost = false,
    CurrentValue = Env.cfg.crosshair.customImage,
    Flag = "CustomCrosshair",
    Callback = function(Value)
        Env.cfg.crosshair.customImage = Value
        updateCrosshair()
    end,
})

VisualsTab:CreateSection("World Aesthetics")

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local timeLoop
local desiredTime = 14
local freezeTime = false

VisualsTab:CreateToggle({
    Name = "Freeze Time (Bypass Game Cycle)",
    CurrentValue = false,
    Callback = function(v)
        freezeTime = v

        if v then
            timeLoop = RunService.RenderStepped:Connect(function()
                if freezeTime then
                    Lighting.ClockTime = desiredTime
                end
            end)
        else
            if timeLoop then
                timeLoop:Disconnect()
                timeLoop = nil
            end
        end
    end
})

VisualsTab:CreateSlider({
    Name = "Time of Day",
    Range = { 0, 24 },
    Increment = 0.5,
    CurrentValue = desiredTime,
    Callback = function(v)
        desiredTime = v
        if not freezeTime then
            Lighting.ClockTime = v
        end
    end
})

local ColorCorr =
    Lighting:FindFirstChild("CasualWorldTint")
    or Instance.new("ColorCorrectionEffect")

ColorCorr.Name = "CasualWorldTint"
ColorCorr.Parent = Lighting
ColorCorr.Enabled = false

VisualsTab:CreateToggle({
    Name = "Enable World Tint",
    CurrentValue = false,
    Callback = function(v)
        ColorCorr.Enabled = v
    end
})

VisualsTab:CreateColorPicker({
    Name = "Tint Color",
    Color = Color3.fromRGB(255, 255, 255),
    Callback = function(v)
        ColorCorr.TintColor = v
    end
})

VisualsTab:CreateSection("Lighting & Skybox")

VisualsTab:CreateLabel("Tip: Increase Ambient to see Sky at Night")

VisualsTab:CreateColorPicker({
    Name = "Ambient Color (Brightness)",
    Color = Lighting.Ambient,
    Callback = function(v)
        Lighting.Ambient = v
        Lighting.OutdoorAmbient = v
    end
})

local defaultSky = Lighting:FindFirstChildOfClass("Sky")

if not defaultSky then
    defaultSky = Instance.new("Sky")
    defaultSky.Name = "DefaultSky"
    defaultSky.Parent = Lighting
end

local origSky = {
    Bk = defaultSky.SkyboxBk,
    Dn = defaultSky.SkyboxDn,
    Ft = defaultSky.SkyboxFt,
    Lf = defaultSky.SkyboxLf,
    Rt = defaultSky.SkyboxRt,
    Up = defaultSky.SkyboxUp,
    Sun = defaultSky.SunTextureId,
    Moon = defaultSky.MoonTextureId,
    Stars = defaultSky.StarCount
}

local skyList = {
    ["Default"] = origSky,

    ["Purple Galaxy"] = {
        Bk = "http://www.roblox.com/asset/?id=159454299",
        Dn = "http://www.roblox.com/asset/?id=159454296",
        Ft = "http://www.roblox.com/asset/?id=159454293",
        Lf = "http://www.roblox.com/asset/?id=159454286",
        Rt = "http://www.roblox.com/asset/?id=159454300",
        Up = "http://www.roblox.com/asset/?id=159454288",
        Sun = "",
        Moon = "",
        Stars = 3000
    },

    ["Realism Sky"] = {
        Bk = "rbxassetid://2178907873",
        Dn = "rbxassetid://2178907663",
        Ft = "rbxassetid://2178906994",
        Lf = "rbxassetid://2178907310",
        Rt = "rbxassetid://2178906665",
        Up = "rbxassetid://2178907997",
        Sun = "",
        Moon = "",
        Stars = 0
    },

    ["Red Moon"] = {
        Bk = "rbxassetid://482655387",
        Dn = "rbxassetid://482655387",
        Ft = "rbxassetid://482655387",
        Lf = "rbxassetid://482655387",
        Rt = "rbxassetid://482655387",
        Up = "rbxassetid://482655387",
        Sun = "",
        Moon = "",
        Stars = 3000
    }
}

VisualsTab:CreateDropdown({
    Name = "Skybox Theme",
    Options = { "Default", "Purple Galaxy", "Realism Sky", "Red Moon" },
    CurrentOption = { "Default" },
    MultipleOptions = false,
    Callback = function(option)
        local data = skyList[option[1]]
        if not data then return end

        local sky = Lighting:FindFirstChildOfClass("Sky")
        if not sky then
            sky = Instance.new("Sky")
            sky.Parent = Lighting
        end

        sky.SkyboxBk = data.Bk
        sky.SkyboxDn = data.Dn
        sky.SkyboxFt = data.Ft
        sky.SkyboxLf = data.Lf
        sky.SkyboxRt = data.Rt
        sky.SkyboxUp = data.Up

        if data.Sun ~= nil then sky.SunTextureId = data.Sun end
        if data.Moon ~= nil then sky.MoonTextureId = data.Moon end
        if data.Stars ~= nil then sky.StarCount = data.Stars end
    end
})

VisualsTab:CreateSlider({
    Name = "Fog Distance",
    Range = { 0, 10000 },
    Increment = 10,
    CurrentValue = Lighting.FogEnd,
    Callback = function(v)
        Lighting.FogEnd = v
    end
})

MovementTab:CreateSection('Speed')
MovementTab:CreateToggle({
    Name = 'Enable WalkSpeed',
    CurrentValue = Env.cfg.ws_enabled,
    Callback = function(v)
        Env.cfg.ws_enabled = v
    end,
})
MovementTab:CreateSlider({
    Name = 'WalkSpeed',
    Range = {16, 200},
    Increment = 1,
    CurrentValue = Env.cfg.walkspeed,
    Callback = function(v)
        Env.cfg.walkspeed = v
    end,
})
MovementTab:CreateToggle({
    Name = 'Enable JumpPower',
    CurrentValue = Env.cfg.jp_enabled,
    Callback = function(v)
        Env.cfg.jp_enabled = v
    end,
})
MovementTab:CreateSlider({
    Name = 'JumpPower',
    Range = {50, 500},
    Increment = 1,
    CurrentValue = Env.cfg.jumppower,
    Callback = function(v)
        Env.cfg.jumppower = v
    end,
})
MovementTab:CreateSection('Physics')
MovementTab:CreateToggle({
    Name = 'Noclip',
    CurrentValue = Env.cfg.noclip,
    Callback = function(v)
        Env.cfg.noclip = v

        updateNoclip()
    end,
})

MovementTab:CreateSection('Teleports')

local function tp(pos)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    end
end

MovementTab:CreateButton({
    Name = 'Yard',
    Callback = function()
        tp(Vector3.new(780, 98, 2470))
    end,
})
MovementTab:CreateButton({
    Name = 'Prison Interior',
    Callback = function()
        tp(Vector3.new(913, 100, 2388))
    end,
})
MovementTab:CreateButton({
    Name = 'Armory',
    Callback = function()
        tp(Vector3.new(831, 100, 2233))
    end,
})
MovementTab:CreateButton({
    Name = 'Cafeteria',
    Callback = function()
        tp(Vector3.new(905, 100, 2316))
    end,
})
MovementTab:CreateButton({
    Name = 'Criminal Base',
    Callback = function()
        tp(Vector3.new(-931, 94, 2063))
    end,
})
MovementTab:CreateButton({
    Name = 'Instant Escape',
    Callback = function()
        local c = LocalPlayer.Character
        local h = c and c:FindFirstChild('HumanoidRootPart')

        if h then
            local containers = Workspace:FindFirstChild('Shippingcontainers')

            if containers then
                pcall(function()
                    h.CFrame = containers:GetChildren()[6]:GetChildren()[2].CFrame
                end)
            else
                h.CFrame = CFrame.new(-931, 94, 2063)
            end

            task.wait(0.5)

            local hum = c:FindFirstChild('Humanoid')

            if hum then
                hum.Health = 0
            end
        end
    end,
})

VehicleTab:CreateSection('Vehicle Modifications')
VehicleTab:CreateToggle({
    Name = 'Enable Vehicle Mods',
    CurrentValue = Env.cfg.vehicle.enabled,
    Callback = function(v)
        Env.cfg.vehicle.enabled = v

        if v then
            getgenv().startVehicleMonitoring()
        else
            getgenv().stopVehicleMonitoring()
        end
    end,
})
VehicleTab:CreateSlider({
    Name = 'Max Speed',
    Range = {10, 200},
    Increment = 5,
    CurrentValue = Env.cfg.vehicle.maxSpeed,
    Callback = function(v)
        Env.cfg.vehicle.maxSpeed = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Turn Speed',
    Range = {0.5, 5},
    Increment = 0.1,
    CurrentValue = Env.cfg.vehicle.turnSpeed,
    Callback = function(v)
        Env.cfg.vehicle.turnSpeed = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Torque',
    Range = {10, 200},
    Increment = 5,
    CurrentValue = Env.cfg.vehicle.torque,
    Callback = function(v)
        Env.cfg.vehicle.torque = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Steer Responsiveness',
    Range = {0.1, 2},
    Increment = 0.1,
    CurrentValue = Env.cfg.vehicle.steerFloat,
    Callback = function(v)
        Env.cfg.vehicle.steerFloat = v
    end,
})
VehicleTab:CreateSection('Vehicle Flight')

local RunService = game:GetService('RunService')
local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local Player = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local FlyEnabled = false
local FlySpeed = 150

VehicleTab:CreateToggle({
    Name = 'Enable Vehicle Fly',
    CurrentValue = false,
    Flag = 'FlyToggle',
    Callback = function(Value)
        FlyEnabled = Value

        if not FlyEnabled then
            local char = Player.Character

            if char then
                local hum = char:FindFirstChild('Humanoid')

                if hum and hum.SeatPart then
                    local s = hum.SeatPart

                    if s:FindFirstChild('FlyVelocity') then
                        s.FlyVelocity:Destroy()
                    end
                    if s:FindFirstChild('FlyGyro') then
                        s.FlyGyro:Destroy()
                    end
                end
            end
        end
    end,
})
VehicleTab:CreateSlider({
    Name = 'Fly Speed',
    Range = {0, 500},
    Increment = 10,
    Suffix = 'Speed',
    CurrentValue = 150,
    Flag = 'SpeedSlider',
    Callback = function(Value)
        FlySpeed = Value
    end,
})

local function setupVehicle(seat)
    local bv = seat:FindFirstChild('FlyVelocity') or Instance.new('BodyVelocity')

    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.zero
    bv.Name = 'FlyVelocity'
    bv.Parent = seat

    local bg = seat:FindFirstChild('FlyGyro') or Instance.new('BodyGyro')

    bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bg.P = 3000
    bg.D = 100
    bg.CFrame = seat.CFrame
    bg.Name = 'FlyGyro'
    bg.Parent = seat

    return bv, bg
end

RunService.Heartbeat:Connect(function()
    if not FlyEnabled then
        return
    end

    local character = Player.Character

    if not character then
        return
    end

    local humanoid = character:FindFirstChild('Humanoid')

    if not humanoid then
        return
    end

    local seat = humanoid.SeatPart

    if seat and seat:IsA('VehicleSeat') then
        if Camera.CameraSubject ~= humanoid then
            Camera.CameraSubject = humanoid
        end

        seat.AssemblyLinearVelocity = Vector3.zero

        local bv, bg = setupVehicle(seat)
        local throttle = seat.Throttle
        local steer = seat.Steer

        if math.abs(throttle) > 0 then
            bv.Velocity = Camera.CFrame.LookVector * (throttle * FlySpeed)
            bg.CFrame = Camera.CFrame * CFrame.Angles(0, 0, -steer * 0.5)
        else
            bv.Velocity = Vector3.zero
            bg.CFrame = seat.CFrame
        end
    end
end)
UtilityTab:CreateSection('Bypass')
UtilityTab:CreateToggle({
    Name = 'Walk While Arrested',
    CurrentValue = Env.cfg.shootarrested,
    Callback = function(v)
        Env.cfg.shootarrested = v
    end,
})
UtilityTab:CreateSection('Item Pickup')
UtilityTab:CreateToggle({
    Name = 'Auto Grab Items',
    CurrentValue = Env.cfg.autograb,
    Callback = function(v)
        Env.cfg.autograb = v
    end,
})
ConfigTab:CreateSection('Configuration Manager')

local configNameInput = ''

ConfigTab:CreateInput({
    Name = 'Config Name',
    PlaceholderText = 'Enter config name...',
    RemoveTextAfterFocusLost = false,
    Callback = function(t)
        configNameInput = t
    end,
})
ConfigTab:CreateButton({
    Name = 'Save Config',
    Callback = function()
        if configNameInput == '' then
            Rayfield:Notify({
                Title = 'Config',
                Content = 'Please enter a config name!',
                Duration = 3,
            })

            return
        end
        if saveConfig(configNameInput) then
            Rayfield:Notify({
                Title = 'Config Saved',
                Content = 'Saved: ' .. configNameInput,
                Duration = 3,
            })
        else
            Rayfield:Notify({
                Title = 'Config Error',
                Content = 'Failed to save config!',
                Duration = 3,
            })
        end
    end,
})
ConfigTab:CreateButton({
    Name = 'Load Config',
    Callback = function()
        if configNameInput == '' then
            Rayfield:Notify({
                Title = 'Config',
                Content = 'Please enter a config name!',
                Duration = 3,
            })

            return
        end
        if loadConfig(configNameInput) then
            Rayfield:Notify({
                Title = 'Config Loaded',
                Content = 'Loaded: ' .. configNameInput,
                Duration = 3,
            })
        else
            Rayfield:Notify({
                Title = 'Config Error',
                Content = 'Config not found!',
                Duration = 3,
            })
        end
    end,
})
ConfigTab:CreateSection('Reset')
ConfigTab:CreateButton({
    Name = 'Reset to Defaults',
    Callback = function()
        Env.cfg.enabled = true
        Env.cfg.teamcheck = false
        Env.cfg.esp = false
        Env.cfg.autoarrest = false
        Env.cfg.punchaura = false
        Env.cfg.noclip = false
        Env.cfg.shootarrested = false
        Env.cfg.autograb = false
        Env.cfg.ws_enabled = false
        Env.cfg.jp_enabled = false

        updateNoclip()
        Env.updateEsp()
        Rayfield:Notify({
            Title = 'Reset Complete',
            Content = 'All settings restored to default',


            Duration = 3,
        })
    end,
})
Rayfield:Notify({
    Title = 'Welcome!',
    Content = 'Casual Comas v' .. Env.Version,
    Duration = 5,
})


--[[CC PART I(DEPENDENCY)

getgenv().PL_Hub = getgenv().PL_Hub or {}
local Env = getgenv().PL_Hub

Env.Version = "1.0.0"

Env.Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    StarterGui = game:GetService("StarterGui"),
    TweenService = game:GetService("TweenService"),
    CoreGui = game:GetService("CoreGui"),
    GuiService = game:GetService("GuiService"),
    Teams = game:GetService("Teams"),
    HttpService = game:GetService("HttpService"),
    Debris = game:GetService("Debris"),
    SoundService = game:GetService("SoundService")
}

local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer

Env.Teams = {
    Guards = Env.Services.Teams:FindFirstChild("Guards"),
    Inmates = Env.Services.Teams:FindFirstChild("Inmates"),
    Criminals = Env.Services.Teams:FindFirstChild("Criminals")
}

Env.cfg = {
    enabled = false,
    teamcheck = true,
    wallcheck = true,
    deathcheck = true,
    ffcheck = true,
    hostilecheck = true,
    trespasscheck = true,
    vehiclecheck = true,
    criminalsnoinnmates = true,
    inmatesnocriminals = true,
    shieldbreaker = false,
    shieldfrontangle = 0.3,
    shieldrandomhead = false,
    shieldheadchance = 30,
    taserbypasshostile = false,
    taserbypasstrespass = false,
    taseralwayshit = false,
    ifplayerstill = false,
    stillthreshold = 0.5,
    hitchance = 100,
    hitchanceAutoOnly = false,
    missspread = 5,
    shotgunnaturalspread = false,
    shotgungamehandled = false,
    prioritizeclosest = false,
    targetstickiness = false,
    targetstickinessduration = 0.6,
    targetstickinessrandom = false,
    targetstickinessmin = 0.3,
    targetstickinessmax = 0.7,
    fov = 120,
    showfov = true,
    showtargetline = false,
    togglekey = Enum.KeyCode.RightShift,
    aimpart = "Head",
    randomparts = true,
    partslist = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "HumanoidRootPart"},
    esp = false,
    espteamcheck = true,
    espshowteam = false,
    esptargets = {guards = true, inmates = true, criminals = true},
    espmaxdist = 500,
    espshowdist = true,
    esptoggle = Enum.KeyCode.RightControl,
    espcolor = Color3.fromRGB(0, 170, 255),
    espguards = Color3.fromRGB(0, 170, 255),
    espinmates = Color3.fromRGB(255, 150, 50),
    espcriminals = Color3.fromRGB(255, 60, 60),
    espteam = Color3.fromRGB(60, 255, 60),
    espuseteamcolors = true,
    autoshoot = true,
    autoshootdelay = 0.12,
    autoshootstartdelay = 0.2,
    c4esp = false,
    c4esptoggle = Enum.KeyCode.B,
    c4espcolor = Color3.fromRGB(80, 255, 80),
    c4espmaxdist = 200,
    c4espshowdist = true,
    hitsound = {
        enabled = true,
        volume = 2,
        normal = 1129547534,
        headshot = 108290646184559
    },
    tracer = {
        enabled = true,
        color = Color3.fromRGB(255, 255, 255),
        thickness = 0.12,
        lifetime = 0.15,
        fade = 0.2
    },
    hitmarker = {
        enabled = true,
        thickness = 1.5,
        length = 6,
        gap = 3,
        expand = 8,
        headExpand = 14
    },
    crosshair = {
        customImage = ""
    }
}

Env.wallParams = RaycastParams.new()
Env.wallParams.FilterType = Enum.RaycastFilterType.Exclude
Env.wallParams.IgnoreWater = true
Env.wallParams.RespectCanCollide = false
Env.wallParams.CollisionGroup = "ClientBullet"

Env.vars = {
    currentGun = nil,
    rng = Random.new(),
    lastShotTime = 0,
    lastShotResult = false,
    currentTarget = nil,
    targetSwitchTime = 0,
    currentStickiness = 0
}

Env.partMap = {
    ["Torso"] = {"Torso", "UpperTorso", "LowerTorso"},
    ["LeftArm"] = {"Left Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand"},
    ["RightArm"] = {"Right Arm", "RightUpperArm", "RightLowerArm", "RightHand"},
    ["LeftLeg"] = {"Left Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot"},
    ["RightLeg"] = {"Right Leg", "RightUpperLeg", "RightLowerLeg", "RightFoot"}
}

function Env.getPart(char, name)
    if not char then return nil end
    local p = char:FindFirstChild(name)
    if p then return p end
    local maps = Env.partMap[name]
    if maps then
        for _, n in ipairs(maps) do
            local part = char:FindFirstChild(n)
            if part then return part end
        end
    end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
end

function Env.isHeadshot(hitPart)
    if hitPart.Name == "Head" then return true end
    
    local char = hitPart:FindFirstAncestorOfClass("Model")
    if not char then return false end
    
    local head = char:FindFirstChild("Head")
    if not head then return false end
    
    if hitPart:IsA("Accessory") or hitPart:IsA("Hat") then
        local attachment = hitPart:FindFirstChildOfClass("Attachment")
        if attachment then
            local headAttachment = head:FindFirstChild(attachment.Name)
            if headAttachment then return true end
        end
    end
    
    if hitPart.Parent and hitPart.Parent:IsA("Accessory") then
        local accessory = hitPart.Parent
        local handle = accessory:FindFirstChild("Handle")
        if handle then
            local attachment = handle:FindFirstChildOfClass("Attachment")
            if attachment then
                local headAttachment = head:FindFirstChild(attachment.Name)
                if headAttachment then return true end
            end
        end
    end
    
    return false
end

function Env.getTargetPart(char)
    if not char then return nil end
    if Env.cfg.shieldbreaker then
        local shield = char:FindFirstChild("RiotShieldPart")
        if shield and shield:IsA("BasePart") then
            local hp = shield:GetAttribute("Health")
            if hp and hp > 0 then
                local myChar = LocalPlayer.Character
                local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                local theirHrp = char:FindFirstChild("HumanoidRootPart")
                if myHrp and theirHrp then
                    local toMe = (myHrp.Position - theirHrp.Position).Unit
                    local theirLook = theirHrp.CFrame.LookVector
                    local dot = toMe:Dot(theirLook)
                    if dot > Env.cfg.shieldfrontangle then
                        if Env.cfg.shieldrandomhead and Env.vars.rng:NextInteger(1, 100) <= Env.cfg.shieldheadchance then
                            return Env.getPart(char, "Head")
                        end
                        return shield
                    end
                end
            end
        end
    end
    local partName
    if Env.cfg.randomparts then
        local list = Env.cfg.partslist
        partName = (list and #list > 0) and list[Env.vars.rng:NextInteger(1, #list)] or "Head"
    else
        partName = Env.cfg.aimpart
    end
    return Env.getPart(char, partName)
end

function Env.isDead(player)
    if not player or not player.Character then return true end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return not humanoid or humanoid.Health <= 0
end

function Env.isStanding(player)
    if not player or not player.Character then return false end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local vel = hrp.AssemblyLinearVelocity
    return Vector2.new(vel.X, vel.Z).Magnitude <= Env.cfg.stillthreshold
end

function Env.hasForceField(player)
    if not player or not player.Character then return false end
    return player.Character:FindFirstChildOfClass("ForceField") ~= nil
end

function Env.isInVehicle(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    return humanoid.SeatPart ~= nil
end

function Env.wallBetween(startPos, endPos, targetChar)
    local myChar = LocalPlayer.Character
    if not myChar then return true end
    local filter = {myChar}
    if targetChar then table.insert(filter, targetChar) end
    Env.wallParams.FilterDescendantsInstances = filter
    local direction = endPos - startPos
    local distance = direction.Magnitude
    local unit = direction.Unit
    local currentStart = startPos
    local remaining = distance
    for _ = 1, 10 do
        local result = workspace:Raycast(currentStart, unit * remaining, Env.wallParams)
        if not result then return false end
        local hit = result.Instance
        if hit.Transparency < 0.8 and hit.CanCollide then return true end
        local hitDist = (result.Position - currentStart).Magnitude
        remaining = remaining - hitDist - 0.01
        if remaining <= 0 then return false end
        currentStart = result.Position + unit * 0.01
    end
    return false
end

function Env.quickCheck(player)
    if not player or player == LocalPlayer or not player.Character then return false end
    if not Env.getTargetPart(player.Character) then return false end
    if Env.cfg.deathcheck and Env.isDead(player) then return false end
    if Env.cfg.ffcheck and Env.hasForceField(player) then return false end
    if Env.cfg.vehiclecheck and Env.isInVehicle(player) then return false end
    if Env.cfg.teamcheck and player.Team == LocalPlayer.Team then return false end
    if Env.cfg.criminalsnoinnmates then
        if LocalPlayer.Team == Env.Teams.Criminals and player.Team == Env.Teams.Inmates then return false end
    end
    if Env.cfg.inmatesnocriminals then
        if LocalPlayer.Team == Env.Teams.Inmates and player.Team == Env.Teams.Criminals then return false end
    end
    if Env.cfg.hostilecheck or Env.cfg.trespasscheck then
        local isTaser = Env.vars.currentGun and Env.vars.currentGun:GetAttribute("Projectile") == "Taser"
        local bypassHostile = Env.cfg.taserbypasshostile and isTaser
        local bypassTrespass = Env.cfg.taserbypasstrespass and isTaser
        local targetChar = player.Character
        if LocalPlayer.Team == Env.Teams.Guards and player.Team == Env.Teams.Inmates then
            local hostile = targetChar:GetAttribute("Hostile")
            local trespass = targetChar:GetAttribute("Trespassing")
            if Env.cfg.hostilecheck and Env.cfg.trespasscheck then
                if not bypassHostile and not bypassTrespass then
                    if not hostile and not trespass then return false end
                end
            elseif Env.cfg.hostilecheck and not bypassHostile then
                if not hostile then return false end
            elseif Env.cfg.trespasscheck and not bypassTrespass then
                if not trespass then return false end
            end
        end
    end
    return true
end

function Env.fullCheck(player)
    if not Env.quickCheck(player) then return false end
    if Env.cfg.wallcheck then
        local myChar = LocalPlayer.Character
        local myHead = myChar and myChar:FindFirstChild("Head")
        local targetPart = Env.getTargetPart(player.Character)
        if myHead and targetPart then
            if Env.wallBetween(myHead.Position, targetPart.Position, player.Character) then
                return false
            end
        end
    end
    return true
end

function Env.rollHit()
    local now = os.clock()
    if now - Env.vars.lastShotTime > 0.15 then
        Env.vars.lastShotTime = now
        local chance = Env.cfg.hitchance
        if chance >= 100 then
            Env.vars.lastShotResult = true
        elseif chance <= 0 then
            Env.vars.lastShotResult = false
        else
            Env.vars.lastShotResult = Env.vars.rng:NextInteger(1, 100) <= chance
        end
    end
    return Env.vars.lastShotResult
end

function Env.getMissPos(targetPos)
    local spread = Env.cfg.missspread
    local angle = Env.vars.rng:NextNumber() * math.pi * 2
    local d = Env.vars.rng:NextNumber() * spread
    local yOffset = (Env.vars.rng:NextNumber() - 0.5) * spread
    return targetPos + Vector3.new(math.cos(angle) * d, yOffset, math.sin(angle) * d)
end

function Env.getClosest(fovRadius)
    fovRadius = fovRadius or Env.cfg.fov
    local camera = workspace.CurrentCamera
    if not camera then return nil, nil end

    local lastInput = Env.Services.UserInputService:GetLastInputType()
    local locked = (lastInput == Enum.UserInputType.Touch) or (Env.Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)

    local aimPos
    if locked then
        local viewportSize = camera.ViewportSize
        aimPos = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    else
        aimPos = Env.Services.UserInputService:GetMouseLocation()
    end

    local now = os.clock()

    if Env.cfg.targetstickiness and Env.vars.currentTarget and (now - Env.vars.targetSwitchTime) < Env.vars.currentStickiness then
        if Env.fullCheck(Env.vars.currentTarget) then
            local part = Env.getTargetPart(Env.vars.currentTarget.Character)
            if part then
                local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen and screenPos.Z > 0 then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - aimPos).Magnitude
                    if dist < fovRadius then
                        return Env.vars.currentTarget, part.Position
                    end
                end
            end
        end
    end

    local candidates = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if Env.quickCheck(player) then
            local part = Env.getTargetPart(player.Character)
            if part then
                local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen and screenPos.Z > 0 then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - aimPos).Magnitude
                    if dist < fovRadius then
                        candidates[#candidates + 1] = {player = player, dist = dist, part = part}
                    end
                end
            end
        end
    end

    if Env.cfg.prioritizeclosest then
        table.sort(candidates, function(a, b) return a.dist < b.dist end)
    else
        for i = #candidates, 2, -1 do
            local j = Env.vars.rng:NextInteger(1, i)
            candidates[i], candidates[j] = candidates[j], candidates[i]
        end
    end

    for _, candidate in ipairs(candidates) do
        if Env.fullCheck(candidate.player) then
            if candidate.player ~= Env.vars.currentTarget then
                Env.vars.currentTarget = candidate.player
                Env.vars.targetSwitchTime = now
                if Env.cfg.targetstickinessrandom then
                    Env.vars.currentStickiness = Env.vars.rng:NextNumber(Env.cfg.targetstickinessmin, Env.cfg.targetstickinessmax)
                else
                    Env.vars.currentStickiness = Env.cfg.targetstickinessduration
                end
            end
            return candidate.player, candidate.part.Position
        end
    end

    Env.vars.currentTarget = nil
    return nil, nil
end

local Camera = workspace.CurrentCamera
local HitSound = Instance.new("Sound")
HitSound.Volume = Env.cfg.hitsound.volume
HitSound.Parent = Env.Services.SoundService

function Env.spawnHitmark(worldPos, isHead)
    if not Env.cfg.hitmarker.enabled then return end
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    if not onScreen then return end

    local gui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
    local container = Instance.new("Frame", gui)
    container.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
    container.BackgroundTransparency = 1

    local conf = Env.cfg.hitmarker
    local color = isHead and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    local dist = isHead and conf.headExpand or conf.expand

    for i = 1, 4 do
        local angle = ({45, 135, 225, 315})[i]
        local line = Instance.new("Frame", container)
        line.BackgroundColor3 = color
        line.BorderSizePixel = 0
        line.Size = UDim2.new(0, conf.thickness, 0, conf.length)
        line.AnchorPoint = Vector2.new(0.5, 0)
        line.Rotation = angle
        
        local rad = math.rad(angle)
        line.Position = UDim2.new(0, math.sin(rad) * conf.gap, 0, -math.cos(rad) * conf.gap)
        
        Env.Services.TweenService:Create(line, TweenInfo.new(0.2), {
            Position = UDim2.new(0, math.sin(rad) * (conf.gap + dist), 0, -math.cos(rad) * (conf.gap + dist)),
            BackgroundTransparency = 1
        }):Play()
    end
    Env.Services.Debris:AddItem(gui, 0.25)
end

function Env.updateCrosshair()
    task.spawn(function()
        pcall(function()
            local gui = LocalPlayer.PlayerGui:FindFirstChild("CrosshairGui")
            if gui then
                local frame = gui:FindFirstChild("CrosshairFrame")
                if frame then
                    local dot = frame:FindFirstChild("Dot")
                    if dot and Env.cfg.crosshair.customImage ~= "" then
                        dot.Image = "rbxassetid://" .. Env.cfg.crosshair.customImage
                    end
                end
            end
        end)
    end)
end

function Env.getEquippedTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, v in ipairs(char:GetChildren()) do
        if v:IsA("Tool") then return v end
    end
    return nil
end

function Env.getMuzzlePosition()
    local tool = Env.getEquippedTool()
    if not tool then return nil end
    local muzzle = tool:FindFirstChild("Muzzle", true) or tool:FindFirstChild("MuzzleAttachment", true) or tool:FindFirstChild("Barrel", true)
    if muzzle then
        return muzzle:IsA("Attachment") and muzzle.WorldPosition or muzzle.Position
    end
    local handle = tool:FindFirstChild("Handle")
    return handle and handle.Position or nil
end

function Env.createTracer(fromPos, toPos)
    if not Env.cfg.tracer.enabled then return end
    local p0 = Instance.new("Part", workspace)
    p0.Anchored = true
    p0.CanCollide = false
    p0.Transparency = 1
    p0.Size = Vector3.new(0.1, 0.1, 0.1)
    p0.CFrame = CFrame.new(fromPos)
    
    local p1 = p0:Clone()
    p1.CFrame = CFrame.new(toPos)
    p1.Parent = workspace
    
    local a0 = Instance.new("Attachment", p0)
    local a1 = Instance.new("Attachment", p1)
    local beam = Instance.new("Beam", p0)
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Color = ColorSequence.new(Env.cfg.tracer.color)
    beam.Width0 = Env.cfg.tracer.thickness
    beam.Width1 = Env.cfg.tracer.thickness
    beam.FaceCamera = true
    beam.LightEmission = 1
    
    task.delay(Env.cfg.tracer.lifetime, function()
        Env.Services.TweenService:Create(beam, TweenInfo.new(Env.cfg.tracer.fade), {Transparency = NumberSequence.new(1)}):Play()
    end)
    
    Env.Services.Debris:AddItem(p0, Env.cfg.tracer.lifetime + Env.cfg.tracer.fade + 0.1)
    Env.Services.Debris:AddItem(p1, Env.cfg.tracer.lifetime + Env.cfg.tracer.fade + 0.1)
end

local lastHitTime = 0
function Env.playHitsound(hitPart)
    if not Env.cfg.hitsound.enabled or not hitPart then return end
    local char = hitPart:FindFirstAncestorOfClass("Model")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local plr = char and Players:GetPlayerFromCharacter(char)
    
    if hum and plr and plr ~= LocalPlayer and hum.Health > 0 then
        local now = tick()
        if now - lastHitTime < 0.05 then return end
        lastHitTime = now
        
        local isHead = Env.isHeadshot(hitPart)
        HitSound.SoundId = "rbxassetid://" .. (isHead and Env.cfg.hitsound.headshot or Env.cfg.hitsound.normal)
        HitSound:Play()
        
        Env.spawnHitmark(hitPart.Position, isHead)
    end
end

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    
    if method == "FireServer" and self.Name == "ShootEvent" and Env.cfg.enabled then
        task.spawn(function()
            local shots = args[1]
            if type(shots) ~= "table" then return end
            local muzzlePos = Env.getMuzzlePosition()
            if not muzzlePos then return end
            
            for i, shot in ipairs(shots) do
                if type(shot) == "table" and #shot >= 2 then
                    Env.createTracer(muzzlePos, shot[2])
                    if i == 1 and shot[3] then
                        Env.playHitsound(shot[3])
                    end
                end
            end
        end)
    end
    return old(self, ...)
end)

setreadonly(mt, true)



--]]

--[[ Part II(DEPENDENCY)

local Env = getgenv().PL_Hub

if not Env then
    return warn('Load Part 1 First!')
end

local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer
local RunService = Env.Services.RunService
local Debris = Env.Services.Debris
local ReplicatedStorage = Env.Services.ReplicatedStorage
local fovCircle = Drawing.new('Circle')

fovCircle.Color = Color3.fromRGB(180, 120, 220)
fovCircle.Radius = Env.cfg.fov
fovCircle.Transparency = 0.5
fovCircle.Filled = false
fovCircle.NumSides = 64
fovCircle.Thickness = 1
fovCircle.Visible = Env.cfg.showfov and Env.cfg.enabled

local targetLine = Drawing.new('Line')

targetLine.Color = Color3.fromRGB(0, 255, 0)
targetLine.Thickness = 1
targetLine.Transparency = 0.5
targetLine.Visible = false

local visuals = {container = nil}
local espCache = {}

local function makeVisuals()
    local container

    if gethui then
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false
        screen.Parent = gethui()
        container = screen
    elseif syn and syn.protect_gui then
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false

        syn.protect_gui(screen)

        screen.Parent = Env.Services.CoreGui
        container = screen
    else
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false
        screen.Parent = Env.Services.CoreGui
        container = screen
    end

    visuals.container = container
end
local function makeEsp(player)
    if espCache[player] then
        return espCache[player]
    end

    local esp = Instance.new('BillboardGui')

    esp.Name = 'ESP_' .. player.Name
    esp.AlwaysOnTop = true
    esp.Size = UDim2.new(0, 20, 0, 20)
    esp.StudsOffset = Vector3.new(0, 3, 0)
    esp.LightInfluence = 0

    local diamond = Instance.new('Frame')

    diamond.Name = 'Diamond'
    diamond.BackgroundColor3 = Env.cfg.espcolor
    diamond.BorderSizePixel = 0
    diamond.Size = UDim2.new(0, 10, 0, 10)
    diamond.Position = UDim2.new(0.5, -5, 0.5, -5)
    diamond.Rotation = 45
    diamond.Parent = esp

    local stroke = Instance.new('UIStroke')

    stroke.Color = Color3.new(0, 0, 0)
    stroke.Thickness = 1.5
    stroke.Transparency = 0.3
    stroke.Parent = diamond

    local distLabel = Instance.new('TextLabel')

    distLabel.Name = 'DistanceLabel'
    distLabel.BackgroundTransparency = 1
    distLabel.Size = UDim2.new(0, 60, 0, 16)
    distLabel.Position = UDim2.new(0.5, -30, 1, 2)
    distLabel.Font = Enum.Font.GothamBold
    distLabel.TextSize = 11
    distLabel.TextColor3 = Color3.new(1, 1, 1)
    distLabel.TextStrokeTransparency = 0.5
    distLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    distLabel.Text = ''
    distLabel.Parent = esp

    local nameLabel = Instance.new('TextLabel')

    nameLabel.Name = 'NameLabel'
    nameLabel.BackgroundTransparency = 1
    nameLabel.Size = UDim2.new(0, 100, 0, 14)
    nameLabel.Position = UDim2.new(0.5, -50, 0, -16)
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextSize = 10
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.Text = player.Name
    nameLabel.Parent = esp
    espCache[player] = esp

    return esp
end
local function removeEsp(player)
    local e = espCache[player]

    if e then
        e:Destroy()

        espCache[player] = nil
    end
end
local function shouldShowEsp(player)
    if not player or player == LocalPlayer or not player.Character then
        return false
    end

    local humanoid = player.Character:FindFirstChildOfClass('Humanoid')

    if not humanoid or humanoid.Health <= 0 then
        return false
    end

    local hrp = player.Character:FindFirstChild('HumanoidRootPart')

    if not hrp then
        return false
    end

    local myChar = LocalPlayer.Character

    if not myChar then
        return false
    end

    local myHrp = myChar:FindFirstChild('HumanoidRootPart')

    if not myHrp then
        return false
    end

    local distance = (hrp.Position - myHrp.Position).Magnitude

    if distance > Env.cfg.espmaxdist then
        return false
    end

    local myTeam = LocalPlayer.Team
    local theirTeam = player.Team

    if theirTeam == myTeam then
        if not Env.cfg.espshowteam then
            return false
        end

        return true
    end
    if Env.cfg.espteamcheck then
        local imCrimOrInmate = (myTeam == Env.Teams.Criminals or myTeam == Env.Teams.Inmates)
        local theyCrimOrInmate = (theirTeam == Env.Teams.Criminals or theirTeam == Env.Teams.Inmates)

        if imCrimOrInmate and theyCrimOrInmate then
            return false
        end
    end
    if theirTeam == Env.Teams.Guards then
        return Env.cfg.esptargets.guards
    elseif theirTeam == Env.Teams.Inmates then
        return Env.cfg.esptargets.inmates
    elseif theirTeam == Env.Teams.Criminals then
        return Env.cfg.esptargets.criminals
    end

    return false
end

Env.updateEsp = function()
    if not Env.cfg.esp or not visuals.container then
        for _, e in pairs(espCache)do
            e.Parent = nil
        end

        return
    end

    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')

    for _, player in ipairs(Players:GetPlayers())do
        local show = shouldShowEsp(player)

        if show then
            local char = player.Character
            local hrp = char and char:FindFirstChild('HumanoidRootPart')
            local head = char and char:FindFirstChild('Head')

            if hrp and head then
                local esp = makeEsp(player)

                esp.Adornee = head
                esp.Parent = visuals.container

                local d = esp:FindFirstChild('Diamond')

                if d and Env.cfg.espuseteamcolors then
                    local t = player.Team

                    if t == LocalPlayer.Team then
                        d.BackgroundColor3 = Env.cfg.espteam
                    elseif t == Env.Teams.Guards then
                        d.BackgroundColor3 = Env.cfg.espguards
                    elseif t == Env.Teams.Inmates then
                        d.BackgroundColor3 = Env.cfg.espinmates
                    elseif t == Env.Teams.Criminals then
                        d.BackgroundColor3 = Env.cfg.espcriminals
                    else
                        d.BackgroundColor3 = Env.cfg.espcolor
                    end
                end
                if Env.cfg.espshowdist and myHrp then
                    local label = esp:FindFirstChild('DistanceLabel')

                    if label then
                        label.Text = math.floor((hrp.Position - myHrp.Position).Magnitude) .. 'm'
                        label.Visible = true
                    end
                end
            end
        else
            local e = espCache[player]

            if e then
                e.Parent = nil
            end
        end
    end
end

local c4espCache = {}

local function makeC4Esp(c4Part)
    if c4espCache[c4Part] then
        return c4espCache[c4Part]
    end

    local esp = Instance.new('BillboardGui')

    esp.Name = 'C4ESP_' .. tostring(c4Part)
    esp.AlwaysOnTop = true
    esp.Size = UDim2.new(0, 24, 0, 24)
    esp.StudsOffset = Vector3.new(0, 1, 0)

    local icon = Instance.new('Frame')

    icon.BackgroundColor3 = Env.cfg.c4espcolor
    icon.Size = UDim2.new(0, 14, 0, 14)
    icon.Position = UDim2.new(0.5, -7, 0.5, -7)
    icon.Rotation = 45
    icon.Parent = esp

    local label = Instance.new('TextLabel')

    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0, 60, 0, 14)
    label.Position = UDim2.new(0.5, -30, 1, 2)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 11
    label.TextColor3 = Color3.new(1, 1, 1)
    label.Text = 'C4'
    label.Parent = esp

    local distLabel = Instance.new('TextLabel')

    distLabel.Name = 'DistLabel'
    distLabel.BackgroundTransparency = 1
    distLabel.Size = UDim2.new(0, 60, 0, 12)
    distLabel.Position = UDim2.new(0.5, -30, 1, 16)
    distLabel.Font = Enum.Font.GothamBold
    distLabel.TextSize = 10
    distLabel.TextColor3 = Env.cfg.c4espcolor
    distLabel.Text = ''
    distLabel.Parent = esp
    c4espCache[c4Part] = esp

    return esp
end

local trackedC4s = {}

local function isC4Part(part)
    if not part or not part:IsA('BasePart') then
        return false
    end

    local name = part.Name:lower()
    local parentName = part.Parent and part.Parent.Name:lower() or ''

    return name == 'explosive' or name == 'c4' or name == 'clientc4' or parentName:find('c4') or name:find('c4')
end
local function onDescendantAdded(desc)
    if isC4Part(desc) then
        trackedC4s[desc] = true
    end
end
local function onDescendantRemoving(desc)
    trackedC4s[desc] = nil

    if c4espCache[desc] then
        c4espCache[desc]:Destroy()

        c4espCache[desc] = nil
    end
end

for _, desc in ipairs(workspace:GetDescendants())do
    if isC4Part(desc) then
        trackedC4s[desc] = true
    end
end

workspace.DescendantAdded:Connect(onDescendantAdded)
workspace.DescendantRemoving:Connect(onDescendantRemoving)

Env.updateC4Esp = function()
    if not Env.cfg.c4esp or not visuals.container then
        for _, e in pairs(c4espCache)do
            e.Parent = nil
        end

        return
    end

    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')

    for part in pairs(trackedC4s)do
        if part and part:IsDescendantOf(workspace) then
            local dist = myHrp and (part.Position - myHrp.Position).Magnitude or 0

            if dist <= Env.cfg.c4espmaxdist then
                local esp = makeC4Esp(part)

                esp.Adornee = part
                esp.Parent = visuals.container

                if Env.cfg.c4espshowdist and myHrp then
                    local distLabel = esp:FindFirstChild('DistLabel')

                    if distLabel then
                        distLabel.Text = math.floor(dist) .. 'm'
                    end
                end
            else
                if c4espCache[part] then
                    c4espCache[part].Parent = nil
                end
            end
        else
            trackedC4s[part] = nil

            if c4espCache[part] then
                c4espCache[part]:Destroy()

                c4espCache[part] = nil
            end
        end
    end
end

makeVisuals()

local ShootEvent = ReplicatedStorage:WaitForChild('GunRemotes'):WaitForChild('ShootEvent')
local lastAutoShoot = 0
local targetAcquiredTime = 0
local lastAutoTarget = nil
local cachedBulletsLabel = nil

local function createBulletTrail(startPos, endPos, isTaser)
    local distance = (endPos - startPos).Magnitude
    local trail = Instance.new('Part')

    trail.Name = 'BulletTrail'
    trail.Anchored = true
    trail.CanCollide = false
    trail.Material = Enum.Material.Neon
    trail.Size = Vector3.new(0.1, 0.1, distance)
    trail.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -distance / 2)
    trail.Transparency = 0.5

    if isTaser then
        trail.BrickColor = BrickColor.new('Cyan')
        trail.Size = Vector3.new(0.2, 0.2, distance)
    else
        trail.BrickColor = BrickColor.Yellow()
    end

    trail.Parent = workspace

    Debris:AddItem(trail, isTaser and 0.8 or 0.1)
end
local function autoShoot()
    if not Env.cfg.autoshoot or not Env.cfg.enabled or not Env.vars.currentGun then
        return
    end
    if Env.vars.currentGun:GetAttribute('Local_IsShooting') then
        return
    end
    if (Env.vars.currentGun:GetAttribute('Local_ReloadSession') or 0) > 0 then
        return
    end

    local now = os.clock()
    local fireRate = Env.vars.currentGun:GetAttribute('FireRate') or Env.cfg.autoshootdelay

    if now - lastAutoShoot < fireRate then
        return
    end

    local myChar = LocalPlayer.Character

    if not myChar then
        return
    end

    local myHead = myChar:FindFirstChild('Head')

    if not myHead then
        return
    end

    local muzzle = Env.vars.currentGun:FindFirstChild('Muzzle')
    local startPos = muzzle and muzzle.Position or myHead.Position
    local target, targetPos = Env.getClosest(Env.cfg.fov)

    if not target or not Env.fullCheck(target) then
        lastAutoTarget = nil

        return
    end
    if target ~= lastAutoTarget then
        targetAcquiredTime = now
        lastAutoTarget = target
    end
    if now - targetAcquiredTime < Env.cfg.autoshootstartdelay then
        return
    end

    local targetPart = Env.getTargetPart(target.Character)

    if not targetPart then
        return
    end

    local ammo = Env.vars.currentGun:GetAttribute('Local_CurrentAmmo') or Env.vars.currentGun:GetAttribute('CurrentAmmo') or 0

    if ammo <= 0 then
        return
    end

    lastAutoShoot = now

    local isTaser = Env.vars.currentGun:GetAttribute('Projectile') == 'Taser'
    local isShotgun = Env.vars.currentGun:GetAttribute('IsShotgun')
    local shouldHit = false

    if Env.cfg.taseralwayshit and isTaser then
        shouldHit = true
    elseif Env.cfg.ifplayerstill and Env.isStanding(target) then
        shouldHit = true
    elseif Env.cfg.hitchanceAutoOnly and isShotgun then
        shouldHit = true
    else
        shouldHit = Env.rollHit()
    end

    local projectileCount = Env.vars.currentGun:GetAttribute('ProjectileCount') or 1
    local shots = {}

    for i = 1, projectileCount do
        local finalPos

        if shouldHit then
            finalPos = targetPart.Position
        else
            if Env.cfg.missspread > 0 then
                finalPos = Env.getMissPos(targetPart.Position)
            else
                return
            end
        end

        shots[i] = {
            myHead.Position,
            finalPos,
            shouldHit and targetPart or nil,
        }

        createBulletTrail(startPos, finalPos, isTaser)
    end

    ShootEvent:FireServer(shots)

    local newAmmo = ammo - 1

    Env.vars.currentGun:SetAttribute('Local_CurrentAmmo', newAmmo)

    if not cachedBulletsLabel then
        local playerGui = LocalPlayer:FindFirstChild('PlayerGui')

        if playerGui then
            local home = playerGui:FindFirstChild('Home')

            if home and home:FindFirstChild('hud') then
                local br = home.hud:FindFirstChild('BottomRightFrame')

                if br and br:FindFirstChild('GunFrame') then
                    cachedBulletsLabel = br.GunFrame:FindFirstChild('BulletsLabel')
                end
            end
        end
    end
    if cachedBulletsLabel then
        cachedBulletsLabel.Text = newAmmo .. '/' .. (Env.vars.currentGun:GetAttribute('MaxAmmo') or 30)
    end

    local handle = Env.vars.currentGun:FindFirstChild('Handle')

    if handle and handle:FindFirstChild('ShootSound') then
        local sound = handle.ShootSound:Clone()

        sound.Parent = handle

        sound:Play()
        Debris:AddItem(sound, 2)
    end
end
local function getGun()
    local char = LocalPlayer.Character

    if not char then
        return nil
    end

    for _, tool in ipairs(char:GetChildren())do
        if tool:IsA('Tool') and tool:GetAttribute('ToolType') == 'Gun' then
            return tool
        end
    end

    return nil
end

local lastGun = nil

RunService.Heartbeat:Connect(function()
    Env.vars.currentGun = getGun()

    if Env.vars.currentGun ~= lastGun then
        lastAutoShoot = 0
        lastGun = Env.vars.currentGun
    end

    autoShoot()
end)
RunService.PreRender:Connect(function()
    local aimPos = Env.Services.UserInputService:GetMouseLocation()
    local camera = workspace.CurrentCamera

    if camera then
        local lastInput = Env.Services.UserInputService:GetLastInputType()
        local locked = (lastInput == Enum.UserInputType.Touch) or (Env.Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)

        if locked then
            local viewportSize = camera.ViewportSize

            aimPos = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
        end
    end

    fovCircle.Position = aimPos
    fovCircle.Radius = Env.cfg.fov
    fovCircle.Visible = Env.cfg.showfov and Env.cfg.enabled

    if Env.cfg.showtargetline and Env.cfg.enabled then
        local target, targetPos = Env.getClosest()

        if target and targetPos and camera then
            local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)

            if onScreen then
                targetLine.From = aimPos
                targetLine.To = Vector2.new(screenPos.X, screenPos.Y)
                targetLine.Visible = true
            else
                targetLine.Visible = false
            end
        else
            targetLine.Visible = false
        end
    else
        targetLine.Visible = false
    end

    Env.updateEsp()
    Env.updateC4Esp()
end)
Players.PlayerRemoving:Connect(removeEsp)
LocalPlayer:GetPropertyChangedSignal('Team'):Connect(function()
    for player, e in pairs(espCache)do
        if e then
            e:Destroy()
        end

        espCache[player] = nil
    end
end)

local origCastRay
local hooked = false

local function setupHook()
    local castRayFunc = filtergc('function', {
        Name = 'castRay',
    }, true)

    if not castRayFunc then
        return false
    end

    origCastRay = hookfunction(castRayFunc, function(startPos, targetPos, ...)
        if not Env.cfg.enabled then
            return origCastRay(startPos, targetPos, ...)
        end

        local closest, closestPos = Env.getClosest(Env.cfg.fov)

        if closest and closest.Character then
            local isTaser = Env.vars.currentGun and Env.vars.currentGun:GetAttribute('Projectile') == 'Taser'
            local isShotgun = Env.vars.currentGun and Env.vars.currentGun:GetAttribute('IsShotgun')
            local shouldHit = false

            if Env.cfg.hitchanceAutoOnly and isShotgun then
                return origCastRay(startPos, targetPos, ...)
            end
            if Env.cfg.shotgungamehandled and isShotgun then
                local targetPart = Env.getTargetPart(closest.Character)

                if targetPart then
                    return origCastRay(startPos, targetPart.Position, ...)
                end

                return origCastRay(startPos, targetPos, ...)
            end
            if Env.cfg.taseralwayshit and isTaser then
                shouldHit = true
            elseif Env.cfg.ifplayerstill and Env.isStanding(closest) then
                shouldHit = true
            else
                shouldHit = Env.rollHit()
            end
            if shouldHit then
                local targetPart = Env.getTargetPart(closest.Character)

                if targetPart then
                    if Env.cfg.shotgunnaturalspread and isShotgun then
                        return origCastRay(startPos, targetPart.Position, ...)
                    end

                    return targetPart, targetPart.Position
                end
            else
                if Env.cfg.missspread > 0 then
                    local targetPart = Env.getTargetPart(closest.Character)

                    if targetPart then
                        local missPos = Env.getMissPos(targetPart.Position)

                        return origCastRay(startPos, missPos, ...)
                    end
                end

                return origCastRay(startPos, targetPos, ...)
            end
        end

        return origCastRay(startPos, targetPos, ...)
    end)

    return true
end

if not setupHook() then
    task.spawn(function()
        while not hooked do
            task.wait(0.5)

            if setupHook() then
                hooked = true
            end
        end
    end)
else
    hooked = true
end



--]]

--[[ VehicleMods (Feature-baesd)

local Env = getgenv().PL_Hub
if not Env then return warn("Load main hub first!") end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Vehicle configuration
if not Env.cfg.vehicle then
    Env.cfg.vehicle = {
        enabled = false,
        maxSpeed = 100,
        turnSpeed = 2,
        torque = 100,
        steerFloat = 1,
        fly = false,
        flySpeed = 1,
    }
end

-- Vehicle references
local currentVehicle = nil
local originalVehicleStats = {}
local vehicleConnection = nil
local FLYING = false
local flyKeyDown = nil
local flyKeyUp = nil
local flyLoop = nil
local BG = nil
local BV = nil

-- Mobile detection
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Find vehicle seat
local function findVehicle()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid and humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat") then
        return humanoid.SeatPart
    end
    return nil
end

-- Get root part of vehicle
local function getVehicleRoot()
    if not currentVehicle then return nil end
    local vehicleModel = currentVehicle.Parent
    if not vehicleModel then return nil end
    return vehicleModel.PrimaryPart or vehicleModel:FindFirstChild("Main") or vehicleModel:FindFirstChild("Body") or currentVehicle
end

-- Apply vehicle modifications
local function applyVehicleMods(vehicle)
    if not vehicle or not Env.cfg.vehicle.enabled then return end
    
    if not originalVehicleStats[vehicle] then
        originalVehicleStats[vehicle] = {
            MaxSpeed = vehicle.MaxSpeed,
            TurnSpeed = vehicle.TurnSpeed,
            Torque = vehicle.Torque,
            Steer = vehicle.Steer
        }
    end
    
    vehicle.MaxSpeed = Env.cfg.vehicle.maxSpeed
    vehicle.TurnSpeed = Env.cfg.vehicle.turnSpeed
    vehicle.Torque = Env.cfg.vehicle.torque
    vehicle.Steer = Env.cfg.vehicle.steerFloat
end

-- Stop fly
local function stopVehicleFly()
    print("[VFly] Stopping...")
    FLYING = false
    
    -- Disconnect fly loop
    if flyLoop then
        flyLoop:Disconnect()
        flyLoop = nil
    end
    
    -- Disconnect input handlers
    if flyKeyDown then
        flyKeyDown:Disconnect()
        flyKeyDown = nil
    end
    if flyKeyUp then
        flyKeyUp:Disconnect()
        flyKeyUp = nil
    end
    
    -- Destroy BodyMovers
    if BG then
        BG:Destroy()
        BG = nil
    end
    if BV then
        BV:Destroy()
        BV = nil
    end
    
    -- Remove mobile UI
    local gui = LocalPlayer.PlayerGui:FindFirstChild("VehicleFlyMobileUI")
    if gui then gui:Destroy() end
    
    pcall(function()
        workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end)
end

-- Vehicle Fly (Infinite Yield style)
local function startVehicleFly()
    print("[VFly] Starting...")
    
    local T = getVehicleRoot()
    if not T then 
        warn("[VFly] No root found!")
        return 
    end
    
    print("[VFly] Using:", T.Name)
    
    -- Stop existing fly
    stopVehicleFly()
    
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0
    
    FLYING = true
    BG = Instance.new('BodyGyro')
    BV = Instance.new('BodyVelocity')
    BG.P = 9e4
    BG.Parent = T
    BV.Parent = T
    BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.cframe = T.CFrame
    BV.velocity = Vector3.new(0, 0, 0)
    BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
    
    -- Fly loop
    flyLoop = RunService.Heartbeat:Connect(function()
        if not FLYING or not Env.cfg.vehicle.fly or not T.Parent then
            stopVehicleFly()
            return
        end
        
        if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
            SPEED = 50
        elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
            SPEED = 0
        end
        
        if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
            BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
            lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
        elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
            BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
        else
            BV.velocity = Vector3.new(0, 0, 0)
        end
        
        BG.cframe = workspace.CurrentCamera.CoordinateFrame
    end)
    
    -- Keyboard controls
    flyKeyDown = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        local KEY = input.KeyCode
        
        if KEY == Enum.KeyCode.W then
            CONTROL.F = Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.S then
            CONTROL.B = -Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.A then
            CONTROL.L = -Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.D then
            CONTROL.R = Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.E then
            CONTROL.Q = Env.cfg.vehicle.flySpeed * 2
        elseif KEY == Enum.KeyCode.Q then
            CONTROL.E = -Env.cfg.vehicle.flySpeed * 2
        end
    end)
    
    flyKeyUp = UserInputService.InputEnded:Connect(function(input)
        local KEY = input.KeyCode
        
        if KEY == Enum.KeyCode.W then
            CONTROL.F = 0
        elseif KEY == Enum.KeyCode.S then
            CONTROL.B = 0
        elseif KEY == Enum.KeyCode.A then
            CONTROL.L = 0
        elseif KEY == Enum.KeyCode.D then
            CONTROL.R = 0
        elseif KEY == Enum.KeyCode.E then
            CONTROL.Q = 0
        elseif KEY == Enum.KeyCode.Q then
            CONTROL.E = 0
        end
    end)
    
    -- Mobile joystick support
    if isMobile then
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            task.spawn(function()
                while FLYING do
                    local moveVector = humanoid.MoveVector
                    
                    -- Convert joystick input to fly controls
                    CONTROL.F = moveVector.Z < 0 and (-moveVector.Z * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.B = moveVector.Z > 0 and (-moveVector.Z * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.L = moveVector.X < 0 and (moveVector.X * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.R = moveVector.X > 0 and (moveVector.X * Env.cfg.vehicle.flySpeed) or 0
                    
                    task.wait(0.05)
                end
            end)
        end
        
        -- Create mobile up/down buttons
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "VehicleFlyMobileUI"
        screenGui.ResetOnSpawn = false
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.Parent = LocalPlayer.PlayerGui
        
        local function createButton(name, position, text)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Size = UDim2.new(0, 70, 0, 70)
            btn.Position = position
            btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            btn.BackgroundTransparency = 0.3
            btn.Text = text
            btn.TextColor3 = Color3.fromRGB(255, 255, 255)
            btn.TextSize = 24
            btn.Font = Enum.Font.GothamBold
            btn.ZIndex = 300
            btn.Parent = screenGui
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = btn
            
            return btn
        end
        
        local upBtn = createButton("Up", UDim2.new(1, -85, 1, -230), "")
        local downBtn = createButton("Down", UDim2.new(1, -85, 1, -150), "")
        
        upBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.Q = Env.cfg.vehicle.flySpeed * 2
                upBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
            end
        end)
        
        upBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.Q = 0
                upBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            end
        end)
        
        downBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.E = -Env.cfg.vehicle.flySpeed * 2
                downBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
            end
        end)
        
        downBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.E = 0
                downBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            end
        end)
    end
    
    print("[VFly] Started successfully!")
end

-- Stop vehicle monitoring
local function stopVehicleMonitoring()
    if vehicleConnection then
        vehicleConnection:Disconnect()
        vehicleConnection = nil
    end
    
    stopVehicleFly()
    
    if currentVehicle and originalVehicleStats[currentVehicle] then
        local stats = originalVehicleStats[currentVehicle]
        pcall(function()
            currentVehicle.MaxSpeed = stats.MaxSpeed
            currentVehicle.TurnSpeed = stats.TurnSpeed
            currentVehicle.Torque = stats.Torque
            currentVehicle.Steer = stats.Steer
        end)
    end
    
    currentVehicle = nil
end

-- Monitor vehicle state
local function startVehicleMonitoring()
    if vehicleConnection then
        vehicleConnection:Disconnect()
    end
    
    vehicleConnection = RunService.Heartbeat:Connect(function()
        local vehicle = findVehicle()
        
        if vehicle ~= currentVehicle then
            currentVehicle = vehicle
            if vehicle then
                applyVehicleMods(vehicle)
                if Env.cfg.vehicle.fly then
                    task.wait(0.1)
                    startVehicleFly()
                end
            else
                stopVehicleFly()
            end
        end
        
        if currentVehicle then
            applyVehicleMods(currentVehicle)
        end
    end)
end

-- Handle character respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    if Env.cfg.vehicle and Env.cfg.vehicle.enabled then
        task.wait(1)
        startVehicleMonitoring()
    end
end)

-- Start monitoring if enabled
if Env.cfg.vehicle and Env.cfg.vehicle.enabled then
    startVehicleMonitoring()
end

-- Export functions to global environment
getgenv().startVehicleMonitoring = startVehicleMonitoring
getgenv().stopVehicleMonitoring = stopVehicleMonitoring
getgenv().startVehicleFly = startVehicleFly
getgenv().stopVehicleFly = stopVehicleFly
getgenv().getCurrentVehicle = function() return currentVehicle end

--]]
